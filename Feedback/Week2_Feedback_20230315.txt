Starting code feedback for Anqi, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 337.88 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: .git, MiniProject, week6, week7, week4, week3, week2, Feedback, HPC, week1, week5

Found the following files in parent directory: README.md, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
*.tmp
*.log
.DS_Store
*/sandbox
.vscode
**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# Anqi's CMEE Coursework Repository
This README file contains details about the modules within Anqi Wang's (aw222@ic.ac.uk) CMEE Coursework. This coursework contributes towards the fulfilment of MSc Computational Methods in Ecology and Evolution (CMEE) at Imperial College London. <br />

Many of the task requirements and information can be found at [The Mulitilingual Quantitative Biologist](https://mhasoba.github.io/TheMulQuaBio/intro.html)

## Installation

To use scripts in this repository, clone and run.

```bash
git clone git@github.com:AnqiW222/CMEECourseWork.git
```

## Contents
### Week 1: UNIX, Shell scription, LaTeX and Version Control with Git
**Summary:** A brief introduction of the Multilingual Quantitative Biological Methods, UNIX basic knowledge, Introductory shell scripting exercises, Produce scientific documents with LaTeX, and Use version control (Git) to share the files with others<br />
**Language Use:** Bash, LaTex

---

### Week 2: Basic Python Programming
**Summary:** Introduction to writing Python scripts/programs<br />
**Language Use:** Python, Bash

---

### Week 3: R Programming and Data Management & Visualizatio 
**Summary:** Biological Computing in R, Data management and Visualization with R.<br />
**Language Use:** R, LaTeX, Bash

---

### Week 4: Statistics in R
**Summary:** Core Skills Module of PG Life Science, statistical methods that are of wide use in research projects, the different ways of analysing data and the importance of biological interpretation. <br />
**Language Use:** R

---

### Week 5: Spatial Analyses and GIS
**Summary:** Core Skills Module of PG Life Science, using and handling GIS data, along with core concepts in GIS and remote sensing. <br />
**Language Use:** R

---

### Week 6: Genomics and Bioinformatics
**Summary:** Core Skills Module of PG Life Science, introduce the types of questions that can be addressed with population genomic data, and the theory and computational methodologies that are available for answering these questions. <br />
**Language Use:** R

---

### Week 7: Advanced Python Programming
**Summary:** Advanced Python coding skills with introduction of IDE, profiling code, and using computing language flexible. <br />
**Language Use:** Python, R, Bash

---

### Week 8 + 9: MiniProject
**Summary:** MSc CMEE Miniproject: i) What mathematical models best fit to an empirical dataset; ii) Based upon bacteria growth, mechanistic vs. phenomenological models, which is the best fit. Using all biological computing tools learned so far, from data pre-processing, model fitting, plotting and analysis results, to coding and academic report writing, solve the ecological modelling question.<br />
**Language Use:** Python, R, LaTeX, Bash

---

### Week 10 + 11: High Performance Computing and Math Primer
**Summary:** Using Imperial College's HPC cluster as tools and techniques  to solve biological problems, and dealing with the huge data sets through parallel computing. Introduction to the preliminary requirements for the topics that will be covered during the Maths for Biologists module. <br />
**Language Use:** R, Bash, HPC

## Language Versions
**Python:** 3.9.12 <br />
**R:** 4.2.1 <br />
**bash:** 3.2 <br />
**LaTeX:** 3.141592653-2.6-1.40.24 (TeX Live 2022) <br />
**Jupyter:** Notebook 6.4.8 <br />

All code has been written on a MacOS version 12.6 and any dependencies are detailed below the script names within weekly README files


**********************************************************************

======================================================================
Looking for the weekly directories...

Found 7 weekly directories: week1, week2, week3, week4, week5, week6, week7

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: code, results, data

Found the following files: README.md, .gitignore

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# CMEE Coursework - week 2:

This README file contains details about the scripts from in-classwork and practicals for the second week.

## Description
More information about the python scripts and programs for coursework in **Biological Computing in Python I** section can be found in the Computing Chapter of the book [The Mulitilingual Quantitative Biologist](https://mhasoba.github.io/TheMulQuaBio/notebooks/05-Python_I.html)

## Language

Python

## Dependencies
For some scripts (e.g. debugme.py) in this directory requires [pdb](https://docs.python.org/3/library/pdb.html), it can be installed by:

```bash
pip3 install pdb
```

For the python program (e.g. align_seqs.py) in this directory requires [pandas](https://pandas.pydata.org) installation is required by:

```bash
pip3 install --update pip
pip3 install pandas
```

_The installation commands are used for MacOS, may varied with the different operating system._

## Individual Practicals -- Python scripts

#### align_seqs.py
<font size=2>**Summary:** Find the best alignment for two specific DNA sequences such that they have as many bases matching as possible.<br />
**Input:** n/a <br />
**Dependencies:** pandas, sys, io <br />
**Output:** Result saves to */results/align_seqs_results.txt*.<br />
**Running Instructions:** 
```bash
python3 align_seqs.py 
```
</font>

#### basic_csv.py:
<font size=2>**Summary:** Using the csv package. <br />
**Input:** n/a <br />
**Dependencies:** csv <br />
**Output:** Result prints to terminal <br />
**Running Instructions:** 
```bash
python3 basic_csv.py 
```
</font>


#### basic_io1.py:
<font size=2>**Summary:** Example of importing and exporting data in python; Prints lines from a file. <br />
**Input:** n/a <br />
**Output:** Result prints in terminal. <br />
**Running Instructions:** 
```bash
python3 basic_io1.py 
```
</font>

#### basic_io2.py:
<font size=2>**Summary:** Save data to a file.<br />
**Input:** n/a <br />
**Output:** Result saves to */sandbox/test.txt*. <br />
**Running Instructions:** 
```bash
python3 basic_io2.py 
```
</font>

#### basic_io3:
<font size=2>**Summary:** Store/save an object for later use. <br />
**Input:** 1 n/a <br />
**Dependencies:** pickle <br />
**Output:** Result saves to */sandbox/testp.p*. <br />
**Running Instructions:** 
```bash
python3 basic_io3.py 
```
</font>

#### boilerplate.py:
<font size=2>**Summary:** Template for python programs.<br />
**Input:** n/a <br />
**Dependencies:** sys <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:** 
```bash
python3 boilerplate.py 
```
</font>

#### cfexercises1.py:
<font size=2>**Summary:** Introducion of conditionals and functions. <br />
**Input:** n/a <br />
**Dependencies:** sys <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:** 
```bash
python3 cfexercises1.py 
```
</font>

#### cfexercises2.py:
<font size=2>**Summary:** Examples of loops and conditionals combined. <br />
**Input:** n/a <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:** 
```bash
python3 cfexercises2.py 
```
</font>

#### control_flow.py:
<font size=2>**Summary:** Create various functions which analyse numbers using control flow tools. <br />
**Input:** n/a <br />
**Dependencies:** sys <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:** 
```bash
python3 control_flow.py 
```
</font>

#### debugme.py:
<font size=2>**Summary:** Example of buggy function for debugging.<br />
**Input:** n/a <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:** 
```bash
python3 debugme.py 
```
</font>

#### dictionary.py:
<font size=2>**Summary:** Populate a dictionary derived from taxa so that it maps order names to sets of taxa. <br />
**Input:** n/a <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:** 
```bash
python3 dictionary.py 
```
</font>

#### lc1.py:
<font size=2>**Summary:** Using list comprehensions and loops to make lists from bird data. <br />
**Input:** n/a <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:** 
```bash
python3 lc1.py 
```
</font>

#### lc2.py:
<font size=2>**Summary:** Use list comprehensions and loops to make lists from rainfall data. <br />
**Input:** n/a <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:** 
```bash
python3 lc2.py 
```
</font>

#### loops.py:
<font size=2>**Summary:** Examples of for and while loops. <br />
**Input:** n/a <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:** 
```bash
python3 loops.py 
```
</font>

#### MyExampleScript.py:
<font size=2>**Summary:** Learning to run python scripts. <br />
**Input:** n/a <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:** 
```bash
python3 MyExampleScript.py 
```
</font>

#### oaks_debugme.py:
<font size=2>**Summary:** Understand and debug Oaks_debugme.py; write and modify doctests appropriately. <br />
**Input:** n/a <br />
**Dependencies:** csv, sys, doctest <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:** 
```bash
python3 oaks_dubugme.py 
```
</font>

#### oaks.py:
<font size=2>**Summary:** Examples of comprehensions. <br />
**Input:** n/a <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:** 
```bash
python3 oaks.py 
```
</font>

#### scope.py:
<font size=2>**Summary:** Examples of variable scope and global variables. <br />
**Input:** n/a <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:** 
```bash
python3 scope.py 
```
</font>

#### sysargv.py:
<font size=2>**Summary:** Explains sys.argv in a practical way. <br />
**Input:** Various Arguments <br />
**Dependencies:** sys <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:** 
```bash
python3 sysargv.py 
```
</font>

#### test_control_flow.py:
<font size=2>**Summary:** Introduction of unit testing, contains simple tests for each function embedded in the docstring; functions which exemplify the use of control statements. <br />
**Input:** n/a <br />
**Dependencies:** sys, doctest <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:**
```bash
python3 test_control_flow.py -v 
```
</font>

#### tuple.py:
<font size=2>**Summary:** Print out items from a tuple. <br />
**Input:** n/a <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:**
```bash 
python3 tuple.py 
```
</font>

#### using_name.py:
<font size=2>**Summary:** Example of use of __name__=='__main__' and using_name <br />
**Input:** n/a <br />
**Output:** Result prints to terminal.<br />
**Running Instructions:** 
```bash
python3 using_name.py 
```
</font>

## Groupwork Practicals -- 02_Booming_Bonobos
Cover 3 groupwork practicals:
1. [Align DNA sequences](https://mhasoba.github.io/TheMulQuaBio/notebooks/05-Python_I.html#groupwork-practical-on-align-dna-sequences)
2. [Align DNA sequences2](https://mhasoba.github.io/TheMulQuaBio/notebooks/05-Python_I.html#groupwork-practical-on-align-dna-sequences-2)
3. [Missing oaks problem](https://mhasoba.github.io/TheMulQuaBio/notebooks/05-Python_I.html#groupwork-practical-on-missing-oaks-problem) 

#### align_seqs_fasta.py:
<font size=2>**Summary:** Take two sequences from two fasta files given as arguments, compare alignments of the sequences and print the alignment that gives the most base matches to a new file called *best_match.txt*. <br />
**Input:** n/a <br />
**Output:** Result saves to */results/best_match.txt*.<br />
**Running Instructions:** 
```bash
python3 align_seqs_fasta.py
```
</font>

#### align_seqs_better.py
<font size=2>**Summary:** Save the best alignment of two DNA sequences, taking any two fasta sequences to be aligned as input. <br />
**Input:** Files from */data/fasta/***.fasta* <br />
**Output:** Result saves to */results/align_seqs_better*.<br />
**Running Instructions:** 
```bash
python3 align_seqs_better.py ../data/fasta/407228326.fasta ../data/fasta/407228412.fasta
```
</font>

#### oaks_debugme_groupwork.py
<font size=2>**Summary:** This prints species names for trees from an external .CSV file and searches for Oak trees (Quercus spp.). The Oak trees are then written to an output file in the results directory called *JustOaksData.csv* <br />
**Input:** n/a <br />
**Output:** Result saves to */results/JustOaksData.csv*.<br />
**Running Instructions:** 
```bash
python3 oaks_debugme_groupwork.py 
```
</font>


## Author & Contact

<font size=2>**Name:** ANQI WANG<br />
**Email:** aw222@ic.ac.uk</font>
**********************************************************************

Results directory is empty - good! 

Found 25 code files: scope.py, debugme.py, lc2.py, align_seqs_fasta.py, control_flow.py, loops.py, basic_io3.py, cfexercises1.py, oaks.py, align_seqs_better.py, align_seqs.py, using_name.py, dictionary.py, test_control_flow.py, oaks_debugme_groupwork.py, sysargv.py, tuple.py, cfexercises2.py, basic_io1.py, basic_io2.py, boilerplate.py, MyExampleScript.py, lc1.py, basic_csv.py, oaks_debugme.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file scope.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""blocks of code illustrating variable scope."""

__appname__ = 'scope'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

#_a_global = 10 # a global cariable

#if _a_global >= 5:
#    _b_global = _a_global + 5 # also a global variable

#print("Before calling a_function, outside the function, the value of _a_global is", _a_global)
#print("Before calling a_function, outside the function, the value of _b_global is", _b_global)

def a_function1():
    """Demonstrate that if global variables are altered within a function, they will remain as they were outside of the function;
    local variables are not available outside of the scope of the function they are created in."""
    _a_global = 4 # a local variable

    if _a_global >= 4:
        _b_global = _a_global +5 # also a local variable

    _a_local =3

    print("Inside the function, the value of _a_global is", _a_global)
    print("Inside the function, the value of _b_global is", _b_global)
    print("Inside the function, the value of _a_local is", _a_local)
    
    return None 

#a_function1()

#print("After calling a_function, outside the function, the value of _a_global is (still)", _a_global)
#print("After calling a_function, outside the function, the value of _b_global is (still)", _b_global)

#print("After calling a_function, outside the function, the value of _a_local is ", _a_local)  

###################################################################
#_a_global = 10

def a_function2():
    """Demonstrate global variables are available within functions"""
    _a_local = 4
    
    print("Inside the function, the value _a_local is", _a_local)
    print("Inside the function, the value of _a_global is", _a_global)
    
    return None
    
#a_function2()

#print("Outside the function, the value of _a_global is", _a_global)

####################################################################
#_a_global = 10

#print("Before calling a_function, outside the function, the value of _a_global is", _a_global)

def a_function3():
    """Global variables can be altered from within a function"""
    global _a_global
    _a_global = 5
    _a_local = 4
    
    print("Inside the function, the value of _a_global is", _a_global)
    print("Inside the function, the value _a_local is", _a_local)
    
    return None
    
#a_function3()

#print("After calling a_function, outside the function, the value of _a_global now is", _a_global)

#####################################################################

def a_function4():
    """Nested functions to demonstrate the global keyword will alter local variables globally"""
    _a_global = 10

    def _a_function4_2():
        """Makes the local variable _a_global a global variable, and changes its value globally."""
        global _a_global
        _a_global = 20
    
    print("Before calling a_function2, value of _a_global is", _a_global)

    _a_function4_2()
    
    print("After calling a_function2, value of _a_global is", _a_global)
    
    return None
    
#a_function4()

#print("The value of a_global in main workspace / namespace now is", _a_global)

#################################################################

# _a_global = 10

def a_function5():
    """Nested function to demonstrate that if a variable is defined globally, when altered using the global keyword it's value will be altered everywhere."""

    def _a_function5_2():
        """Alters a global variable using the global keyword."""
        global _a_global
        _a_global = 20
    
    print("Before calling a_function5_2, value of _a_global is ", _a_global)

    _a_function5_2()
    
    print("After calling _a_function5_2, value of _a_global is ", _a_global)

# a_function5()

# print("The value of a_global in main workspace / namespace is ", _a_global)

**********************************************************************

Testing scope.py...

scope.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.02695s

======================================================================
Inspecting script file debugme.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Testing the debugging: originally prodeced ZeroDivisionError;
using ipdb.set_trace() to debug and catch errors with 'try' and 'except' statement"""

__appname__ = 'debugme'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

# Using ipdb.set_trace() to identify the errors
def buggyfunc(x):
    """Original buggyfunction to test the bugs using %pdb"""
    y = x
    # import ipdb; ipdb.set_trace()
    # import pdb; pdb.set_trace()
    for i in range(x):
        y = y-1
        z = x/y
    return z

buggyfunc(20)

# in terminal run: %run debugme.py and expected a ZeroDivisionError

#%pdb
#run debugme.py

# Expand the function
def buggyfunc(x):
    """Expand the fuction by print the result of bugs, shown the bug within the program"""
    y = x
    for i in range(x):
        try:
            y = y-1
            z = x/y
        except:
            print(f"This didn't work;{x = };{y = }")
    return z

buggyfunc(20)

def buggyfunc(x):
    """catch specific types of errors using 'try' and 'except' block"""
    y = x
    for i in range(x):
        try: 
            y = y-1
            z = x/y
        except ZeroDivisionError:
            print(f"The result of dividing a number by zero is undefined")
        except:
            print(f"This didn't work;{x = }; {y = }")
        else:
            print(f"OK; {x = }; {y = }, {z = };")
    return z

buggyfunc(20)
**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2022-23/Coursework/StudentRepos/AnqiWang_/week2/code/debugme.py", line 22, in <module>
    buggyfunc(20)
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2022-23/Coursework/StudentRepos/AnqiWang_/week2/code/debugme.py", line 19, in buggyfunc
    z = x/y
ZeroDivisionError: division by zero

======================================================================
Inspecting script file lc2.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Using loops and list comprehensions to create lists of tuples containing monthly rainfall data from tuples"""
__appname__ = 'lc2'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.
My_List = [ i for i in rainfall if i[1]>100]


# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm. 
Month = [ i[0] for i in rainfall if i[1]<50]



# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !). 
MyList = []
Months = []

for x in rainfall:
    if x[1]>100:
        MyList.append(x)
    elif x[1]<50:
        Month.append(x[0])

print(MyList)

# A good example output is:
#
# Step #1:
# Months and rainfall values when the amount of rain was greater than 100mm:
# [('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
# ... etc.


**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]

**********************************************************************

Code ran without errors

Time consumed = 0.02692s

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

""" This program takes two sequences from two fasta files given as arguments, compares alignments of the sequences 
    and prints the alignment that gives the most base matches to a new file called best_match.txt"""

__appname__ = 'align_seqs_fasta.py'
__author__ = 'Elliott Parnell (EJP122@ic.ac.uk), Jooyoung Ser (jooyoung.ser19@imperial.ac.uk), Anqi Wang (anqi.wang22@imperial.ac.uk), Linke Feng (l.feng22@imperial.ac.uk)'
__version__ = '0.0.1'

## IMPORTS ##
import sys #This module interfaces our program with the operating system.
import os #This is used for moving the file created to results
import csv #used to read from CSV
#import re #Provides regular expression matching opperations


############ COMMENTS ##########
# Will need to update all the comments 


## CONSTANTS ##
my_best_align = None
my_best_score = -1

## FUNCTIONS ##
def read_seq_fasta(fasta1, fasta2):
    """ Function used to import and process DNA sequences from two fasta files"""
    files = [fasta1, fasta2]
    seq_data_return = []
    for fastafile in files:
        seq_data = []
        try:
            with open(fastafile, "r") as ff:
                for line in ff:
                    line =line.strip() # remove trailing newline characters
                    if line.startswith(">"):
                        next
                    else:
                        seq_data.append(line)
                seq_data_return.append("".join(seq_data))
        except AttributeError:
            raise
    return(seq_data_return)


def longer_seq(seq1, seq2):
    """This function takes two strings as input and sets the longer of the two as s1 and the shorter as s2"""
    l1 = len(seq1)
    l2 = len(seq2)
    if l1 >= l2:
        s1 = seq1
        s2 = seq2
    else:
        s1 = seq2
        s2 = seq1
        l1, l2 = l2, l1 # swap the two lengths
    return s1, s2, l1, l2

def calculate_score(s1, s2, l1, l2, startpoint):
    """ A function that calcuates the number of matching bases of a particular alignment of two DNA sequences """
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*" #add a star to the string
                score = score + 1 #add 1 to the score
            else: #this section adds a hypen to indicate it's not a match
                matched = matched + "-"

    return score

def best_alignment(s1, s2, l1, l2, my_best_score, my_best_align):
    """ This function works out the alignment for the two sequences that gives the most base matches """
    for i in range(l1): # Note that you just take the last alignment with the highest score
        z = calculate_score(s1, s2, l1, l2, i)
        if z > my_best_score:
            my_best_align = "." * i + s2 
            my_best_score = z 
    return my_best_align, my_best_score
    
## MAIN FUNCTION ###
def main(argv):
    """ Main function to be called for the script"""
    if len(sys.argv) == 3:
        fasta1 = argv[1]
        fasta2 = argv[2]
    else:
        print("Running script using default fasta files")
        fasta1 = "../data/fasta/407228326.fasta"
        fasta2 = "../data/fasta/407228412.fasta"
    
    two_seq = read_seq_fasta(fasta1, fasta2)
    seq1 = two_seq[0]
    seq2 = two_seq[1]
        
    s1, s2, l1, l2 = longer_seq(seq1, seq2)
   
    final_align, final_score = best_alignment(s1, s2, l1, l2, my_best_score, my_best_align)
    
    #Creates a list to write to file
    output_list = [final_align , s1 , f"Best Score: {final_score}"]

    #Using os and path, opens a file in the results directory to write the output list into 
    cur_path = os.path.dirname(__file__)
    new_path = os.path.relpath('../results/best_match_fasta.txt', cur_path)
    
    with open(new_path, 'w') as f:
        for eachline in output_list:
            f.write(eachline)
            f.write("\n")
    
if __name__ == "__main__":
    """ Makes sure the "main" function is called from command line """
    status = main(sys.argv)
    sys.exit(status)

**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
Running script using default fasta files

**********************************************************************

Code ran without errors

Time consumed = 2.76398s

======================================================================
Inspecting script file control_flow.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Function examples of using control statements"""
__appname__ = 'control_flow'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

import sys

def even_or_odd(x=0): # if not specified, x should take value 0.
    """Find whether a number x is even or odd."""
    if x % 2 == 0: #The conditional if
        return f"{x} is Even!"
    return f"{x} is Odd!"

def largest_divisor_five(x=120):
    """Find which is the largest divisor of x among 2,3,4,5."""
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0: #means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else: # When all other (if, elif) conditions are not met
        return f"No divisor found for {x}!" # Each function can return a value or a variable.
    return f"The largest divisor of {x} is {largest}"

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): #  "range" returns a sequence of integers
        if x % i == 0:
            print(f"{x} is not a prime: {i} is a divisor") 
            return False
    print(f"{x} is a prime!")
    return True 

def find_all_primes(x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
        if is_prime(i):
            allprimes.append(i)
    print(f"There are {len(allprimes)} primes between 2 and {x}")
    return allprimes
      
def main(argv):
    """Main entry point of the program"""
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0

if (__name__ == "__main__"):
    """Makes sure the "main" function is called from command line"""
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is 
**********************************************************************

Code ran without errors

Time consumed = 0.02559s

======================================================================
Inspecting script file loops.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Introduction of 'for' and 'while' loops in Python"""
__appname__ = 'loops'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

#Loop exmples

# FOR loops
for i in range(5):
    print(i)

my_list = [0,2,"geronimo!",3.0,True,False]
for k in my_list:
    print(k)

total = 0
summands = [0,1,11,111,1111]
for s in summands:
    total  = total +s
    print (total)

# WHILE loops
z=0
while z<100:
    z=z+1
    print (z)

#Functions
#def foo(x):
#    """Defining a function for x to calculate x*=x"""
#    x *= x # same as x = x*x
#    print (x)
#    return x

#distinction
#def foo(x):
#    """Defining a function for x to calculate x*=x"""
#    x *= x # same as x = x*x
#    print (x)
#    return x
#y = foo(2)
#y
#type(y)

**********************************************************************

Testing loops.py...

loops.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100

**********************************************************************

Code ran without errors

Time consumed = 0.02877s

======================================================================
Inspecting script file basic_io3.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Storing Objects for later use, write a binary file containing the contents of a dictionary, 
read the file and print its contents"""
__appname__ = 'basic_io3'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

#############################
# STORING OBJECTS
#############################
# To save an object (even complex) for later use
my_dictionary = {"a key": 10, "another key": 11}

import pickle

f = open('../sandbox/testp.p', 'wb')
pickle.dump(my_dictionary, f)
f.close()

# Load the data again
f = open('../sandbox/testp.p','rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)
**********************************************************************

Testing basic_io3.py...

basic_io3.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2022-23/Coursework/StudentRepos/AnqiWang_/week2/code/basic_io3.py", line 18, in <module>
    f = open('../sandbox/testp.p', 'wb')
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/testp.p'

======================================================================
Inspecting script file cfexercises1.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Introduction for conditionals and functions"""
__appname__ = 'cfexercises1'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

import sys

def foo_1(x):
    """define a function that return the square root of x"""
    return x ** 0.5

def foo_2(x,y):
    """define a function contains two arguement x and y, and return the bigger number"""
    if x > y:
        return x
    return y

def foo_3(x, y, z):
    """define a function contains three arguments x, y and z, and made the biggest number to end the sequence"""
    if x > y:
        tmp = y # tmp refers to the space to store the tuple during the swap
        y = x
        x = tmp
    if y > z:
        tmp = y
        z = y
        y = tmp
    return [x, y, z]

def foo_4(x):
    """define a function calculte the factorial of x"""
    result = 1
    for i in range(1, x+1):
        result = result * i
    return  result

def foo_5(x):
    """define a recursive function when x==1"""
    if x == 1:
        return 1
    return x * foo_5(x -1) # runs as a loop untile x=1, then return the value step by step back to the order

def foo_6(x):
    """define a factorial function"""
    facto =1 # Set the variables =1
    while x >= 1: # run the loops when x is greater and equal to 1
        facto = facto * x # multiplies the current iteration by the previous one
        x = x - 1 # Remove one from the x to continues down the loops
    return facto #Once the loop reached to 1, the value of facto will be returned 

def main(argv):
    """Main entry point of the program"""
    print(f'The square root of 10 is: {foo_1(10)} ')
    print(f'The bigger number between 7 and 12 is: {foo_2(7, 12)}')
    print(f'The modified sequence of 77, 100 and 3 with the largest number at the end is: {foo_3(77, 100, 3)}')
    print(f'The factorial of 5 is:{foo_4(5)}')
    print(f'The factorial of 6 is:{foo_5(6)}')
    print(f'The factorial of 7 is:{foo_6(7)}')
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
The square root of 10 is: 3.1622776601683795 
The bigger number between 7 and 12 is: 12
The modified sequence of 77, 100 and 3 with the largest number at the end is: [77, 100, 100]
The factorial of 5 is:120
The factorial of 6 is:720
The factorial of 7 is:5040

**********************************************************************

Code ran without errors

Time consumed = 0.02751s

======================================================================
Inspecting script file oaks.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Examples of comprehensions"""
__appname__ = 'oaks'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

## Finds just those taxa that are oak trees  from a list of species

taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraes',
        ]

def is_an_oak(name):
    """returns only oak species, those that start with 'quercus'"""
    return name.lower().startswith('quercus ')

## Using fo loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species)
print(oaks_loops)

## Using List comprehensions
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

## Get names in UPPER CASE using for loops
oaks_loops = set ()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper())
print(oaks_loops)

## get names in Upper CASe using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)
**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
{'Quercus cerris', 'Quercus robur', 'Quercus petraes'}
{'Quercus cerris', 'Quercus robur', 'Quercus petraes'}
{'QUERCUS ROBUR', 'QUERCUS PETRAES', 'QUERCUS CERRIS'}
{'QUERCUS ROBUR', 'QUERCUS PETRAES', 'QUERCUS CERRIS'}

**********************************************************************

Code ran without errors

Time consumed = 0.02791s

======================================================================
Inspecting script file align_seqs_better.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Save the best alignment of two DNA sequences, taking any two fasta sequences to be aligned as input"""

__appname__ = 'align_seqs_better.py'
__author__ = 'Jooyoung Ser (jooyoung.ser19@imperial.ac.uk), Elliott Parnell (elliott.parnell22@imperial.ac.uk), Anqi Wang (anqi.wang22@imperial.ac.uk), Linke Feng (l.feng22@imperial.ac.uk)'
__version__ = '0.0.1'

# Imports
import sys
import csv

# Functions
def input(fasta1, fasta2):
    """Assign data from two fasta files, rm header&newline character to get two clean sequences"""
    allfiles = []
    with open(fasta1, 'r') as file:
        next(file) # rm header
        seq1 = file.read()
        allfiles.append(seq1)
        seq1 = allfiles[0].replace("\n", "") # rm newline characters

    with open(fasta2, 'r') as file:
        next(file) 
        seq2 = file.read()
        allfiles.append(seq2)
        seq2 = allfiles[1].replace("\n", "")
    return seq1, seq2


def swap_lengths(seq1, seq2): 
    """Longer sequence is assigned to s1, and shorter is to s2"""
    l1 = len(seq1)
    l2 = len(seq2)
    if l1 >= l2:
        s1 = seq1
        s2 = seq2
    else:
        s1 = seq2
        s2 = seq1
        l1, l2 = l2, l1 # swap the two lengths
    return s1, s2, l1, l2

   
def calculate_score(s1, s2, l1, l2, startpoint):
    """Computes a score by returning the number of matches starting from arbitrary startpoint (chosen by user)"""
    matched = "" # to hold string displaying alignements
    score = 0

    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    return score    

def best_match(s1, s2, l1, l2):
    """ Find the best match (highest score) for the two sequences"""
    my_best_align = None
    my_best_score = -1
    
    for startpoint in range(l1): 
        z = calculate_score(s1, s2, l1, l2, startpoint)
        if z > my_best_score: # higher score replace the former score
            my_best_align = ["." * startpoint + s2]  
            my_best_score = z 
        elif z == my_best_score: # if same scores are found, store by appending
            my_best_align.append("." * startpoint + s2)
        
    # output file to the results repo
    f = open('../results/align_seqs_better.txt', 'w')
    f.write(f"My best alignment is:")
    for i in range(len(my_best_align)): # output each result if there are the same score
        f.write(f" \n{my_best_align[i]} \n{s1}\n")
    f.write(f"\nMy best alignment score is: {my_best_score}")
    f.close()
    print("Find the output file ../results/align_seqs_better.txt")
    return 0

def main(argv):
    """Main entry point of the program"""
    if len(argv) >= 2: # if two or more arguments, use the given files
        try: 
            print(f"Run {argv[1]} and {argv[2]}")
            seq1, seq2 = input(argv[1], argv[2])
            s1, s2, l1, l2 = swap_lengths(seq1, seq2)
            best_match(s1, s2, l1, l2)
        except: #wrong files are given
            print("Check your input files(two right files).")
    else: # no right(two)files given, use files by default
         print("No arguments, input files given by default.")
         seq1, seq2 = input("../data/fasta/407228326.fasta", "../data/fasta/407228412.fasta")
         s1, s2, l1, l2 = swap_lengths(seq1, seq2)
         best_match(s1, s2, l1, l2)
       

if __name__ == "__main__": 
    """Makes sure the main function is called from command line"""  
    status = main(sys.argv)
    sys.exit(status)

**********************************************************************

Testing align_seqs_better.py...

align_seqs_better.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
No arguments, input files given by default.
Find the output file ../results/align_seqs_better.txt

**********************************************************************

Code ran without errors

Time consumed = 2.66875s

======================================================================
Inspecting script file align_seqs.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Read nucleotide sequences from .csv file, 
calculate alignments with highest number of matching based
and save the results in to a .txt file"""

__appname__ = 'align_seqs'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

# Imports
import pandas as pd
import sys
import io

### Write and Read .csv files to get the two example sequence ###
# Write two sequence into a .csv file and save in /data
data = {'seq1':['CAATTCGGAT'],'seq2':['ATCGCCGGATTACGGG']}
data_df = pd.DataFrame(data)
data_df.to_csv('../data/align_seq.csv')

# Read .csv file
filename = '../data/align_seq.csv'
df = pd.read_csv(filename)
print(df)

# read the two example sequence to match from the .csv file
def file_input():
    """ Read the csv file to get input sequence
    
    Arguments
    ----------
        no arguments required
    
    Returns
    ----------
    seq1, seq2 : str
        two sequences read from the csv file    
    """
    seq1 = df.iloc[0,1]
    seq2 = df.iloc[0,2]
    return seq1, seq2

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest
def swap_lengths(seq1, seq2):
    """ Assign the longer sequence to s1 and the shorter to s2

    Arguments
    ----------
    seq1 : str
        the seqence 1 read from the input file
    seq2 : str
        the seqence 2 read from the input file

    Returns
    ----------
    s1, s2 : str
        the rearranged sequence 1 and 2
    l1, l2 : int
        the length of sequence 1 and 2
    """
    l1 = len(seq1)
    l2 = len(seq2)
    if l1 >= l2:
        s1 = seq1
        s2 = seq2
    else:
        s1 = seq2
        s2 = seq1
        l1, l2 = l2, l1 # swap the two lengths

    return s1, s2, l1, l2

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    """ Computes a score by returning the number of matches starting from arbitarary startpoint
    
    Arguments
    ----------
    s1, s2 : str
        the rearranged sequences 
    l1, l2 : int
        the length of seq1 and seq2
    startpoint : int
        chosen by user, any number to start matching 
        
    Returns
    ----------
    score : int
        the score of matching alignment 
    """
    # import ipdb; ipdb.set_trace()
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
def best_match(s1, s2, l1, l2):
    """ Finds the best alignment of 2 sequences, s1 and s2, by comparing their matching scores

    Args:
    s1, s2 : str
        the rearranged sequences 
    l1, l2 : int
        the length of seq1 and seq2

    Returns:
    my_best_align : str
        the best macthing alignment sequences
    my_best_score : int
        the best alignment sequences matching score
    """
    my_best_align = None
    my_best_score = -1

    for i in range(l1): # Note that you just take the last alignment with the highest score
        z = calculate_score(s1, s2, l1, l2, i)
        if z > my_best_score:
            my_best_align = "." * i + s2 # think about what this is doing!
            my_best_score = z 
        print(my_best_align)
        print(s1)
        print("Best score:", my_best_score)

    return my_best_align, my_best_score

### Output file ###
def file_output(my_best_align, my_best_score):
    """ Save the best alignment, its score into a .txt file

    Arguements
    ----------
    my_best_align : str
        the best macthing alignment sequences
    my_best_score : int
        the best alignment sequences matching score
    """
    OutputData = {'My best alignment is ':str(my_best_align),'My best score is ':str(my_best_score)}
    OutputData_df = pd.DataFrame(OutputData, index=[0])
    OutputData_df.to_csv('../results/output_align_seq.csv')

def main(argv): 
    """Main entry point of the program"""
    seq1, seq2 = file_input()
    s1, s2, l1, l2 = swap_lengths(seq1, seq2)
    my_best_align, my_best_score = best_match(s1, s2, l1, l2)
    file_output(my_best_align, my_best_score)
    return 0

if __name__ == "__main__": 
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
   Unnamed: 0        seq1              seq2
0           0  CAATTCGGAT  ATCGCCGGATTACGGG
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5
 
CAATTCGGAT
ATCGCCGGATTACGGG
Best score: 5
.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2
 
CAATTCGGAT
ATCGCCGGATTACGGG
Best score: 5
..*---------
..CAATTCGGAT
ATCGCCGGATTACGGG
1
 
CAATTCGGAT
ATCGCCGGATTACGGG
Best score: 5
...--------*-
...CAATTCGGAT
ATCGCCGGATTACGGG
1
 
CAATTCGGAT
ATCGCCGGATTACGGG
Best score: 5
....*---------
....CAATTCGGAT
ATCGCCGGATTACGGG
1
 
CAATTCGGAT
**********************************************************************

Code ran without errors

Time consumed = 0.56729s

======================================================================
Inspecting script file using_name.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Demonstrating how __name__ works"""

__appname__ = 'using_name'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

if __name__ == '__main__':
    print('This program is being run by itself!')
else:
    print('I am being imported from another script/program/module!')

print("This module's name is: " + __name__)
**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
This program is being run by itself!
This module's name is: __main__

**********************************************************************

Code ran without errors

Time consumed = 0.02533s

======================================================================
Inspecting script file dictionary.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Populate a dictionary derived from taxa and maps order names to sets of taxa"""
__appname__ = 'dictionary'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia'),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocßephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

# Write a python script to populate a dictionary called taxa_dic derived from
# taxa so that it maps order names to sets of taxa and prints it to screen.
# 
# An example output is:
#  
# 'Chiroptera' : set(['Myotis lucifugus']) ... etc. OR, 'Chiroptera': {'Myotis
#  lucifugus'} ... etc

#### Your solution here #### 
#del(dict)
#taxa_dic = dict(taxa)


# Method 1
taxa_dic = {}
# j = 0
for i in taxa:
        taxa_dic.setdefault(i[1],set()).add(i[0])
        # print(j)
        # j += 1
        # print(taxa_dic)
print(taxa_dic)

# Method 2
taxa_dic_dc = {x[1]: set([y[0] for y in taxa if y[1] == x[1]]) for x in taxa}

    

# Now write a list comprehension that does the same (including the printing after the dictionary has been created)  
#{x[1]: [[y[0] for y in taxa if ] for x in taxa} 

#### Your solution here #### 

**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
{'Chiroptera': {'Myotis lucifugus'}, 'Rodentia': {'Mus domesticus', 'Cleithrionomys rutilus', 'Gerbillus henleyi', 'Peromyscus crinitus'}, 'Afrosoricida': {'Microgale dobsoni', 'Microgale talazaci'}, 'Carnivora': {'Canis lupus', 'Arctocßephalus gazella', 'Lyacon pictus'}}

**********************************************************************

Code ran without errors

Time consumed = 0.02599s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""A function with unit testing, '%run test_control_flow.py -v' to run this script."""

__appname__ = 'test_control_flow'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

import sys
import doctest # Import the doctest module

def even_or_odd(x=0):
    """Find whether a number x is even or odd.
      
    >>> even_or_odd(10)
    '10 is Even!'
    
    >>> even_or_odd(5)
    '5 is Odd!'
        
    in case of negative numbers, the positive is taken:    
    >>> even_or_odd(-2)
    '-2 is Even!'
    
    """
    #Define function to be tested
    if x % 2 == 0:
        return f"{x} is Even!"
    return f"{x} is Odd!"

def main(argv): 
    """Main entry point of the program"""
    print(even_or_odd(22))
    print(even_or_odd(33))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)

doctest.testmod()   # To run with embedded tests
**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
22 is Even!
33 is Odd!

**********************************************************************

Code ran without errors

Time consumed = 0.05110s

======================================================================
Inspecting script file oaks_debugme_groupwork.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

""" This prints species names for trees from an external CSV file and searches for Oak trees (Quercus spp.).
The Oak trees are then written to an output file in the results directory called JustOaksData.csv"""

__appname__ = 'oaks_debugme.py'
__author__ = 'Jooyoung Ser (ZS519@ic.ac.uk), Elliott Parnell (elliott.parnell22@imperial.ac.uk), Anqi Wang (anqi.wang22@imperial.ac.uk), Linke Feng (l.feng22@imperial.ac.uk)'
__version__ = '0.0.1'

### Import ###
import csv
import sys
import doctest
import re


#Define function

def is_an_oak(name):
    """ Returns True if name is starts with 'quercus'
    >>> is_an_oak('Fagus sylvatica') 
    False
    >>> is_an_oak('Quercus robur')
    True
    >>> is_an_oak("Quercuss")
    True
    """
    return name.lower().strip().startswith('quercus')

def main(argv): 
    """ Main function called by the script"""
    f = open('../data/TestOaksData.csv','r')
    g = open('../data/JustOaksData.csv','w')
    taxa = csv.reader(f)
    csvwrite = csv.writer(g)
    csvwrite.writerow(["Genus", "Species"]) # add the header
    oaks = set()
    for row in taxa:
        if row[0] != "Genus" and is_an_oak(row[0]):
            print(row)
            print ("The genus is: ")
            print(row[0] + '\n')
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])
        elif row[0] != "Genus":
            print(row)
            print ("The genus is: ")
            print(row[0] + '\n')                
    return 0

    
if (__name__ == "__main__"):
    status = main(sys.argv)
    doctest.testmod()
    sys.exit(status)

**********************************************************************

Testing oaks_debugme_groupwork.py...

oaks_debugme_groupwork.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!


**********************************************************************

Code ran without errors

Time consumed = 0.05223s

======================================================================
Inspecting script file sysargv.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Demonstrate sys.argv"""
__appname__ = 'sysargv'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

import sys
print("This is the name of the script: ", sys.argv[0])
print("Number of arguments: ", len(sys.argv))
print("The arguments are: " , str(sys.argv))
**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.02419s

======================================================================
Inspecting script file tuple.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Print out lists cotaining infor of birds (latin names, common names, and body masses) from a tuple"""

__appname__ = 'tuple'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line or output block by
# species 
# 
# A nice example output is:
# 
# Latin name: Passerculus sandwichensis Common name: Savannah sparrow Mass: 18.7
# ... etc.

for x in birds:
    print("latin name:", x[0], "; common name:", x[1], "; mass:", x[2])
**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
latin name: Passerculus sandwichensis ; common name: Savannah sparrow ; mass: 18.7
latin name: Delichon urbica ; common name: House martin ; mass: 19
latin name: Junco phaeonotus ; common name: Yellow-eyed junco ; mass: 19.5
latin name: Junco hyemalis ; common name: Dark-eyed junco ; mass: 19.6
latin name: Tachycineata bicolor ; common name: Tree swallow ; mass: 20.2

**********************************************************************

Code ran without errors

Time consumed = 0.03005s

======================================================================
Inspecting script file cfexercises2.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Examples of loops and conditionals combined"""
__appname__ = 'cfexercises2'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

import sys

###########################
def hello_1(x):
    """For each number from 0, prints hello for numbers up to x which are divisible by 3"""
    for j in range(x):
        if j % 3 == 0:
            print('hello')
    print(' ') 
#hello_1(12)

###########################
def hello_2(x):
    """for each number from 0 to x-1, if meet the requirement, print 'hello'"""
    for j in range(x):
        if j % 5 == 3:
            print('hello')
        elif j % 4 == 3:
            print('hello')
    print(' ')

#hello_2(12)

###########################
def hello_3(x,y):
    """Print hello when the number is in range (x, y)"""
    for i in range(x,y):
        print('hello')
    print(' ')

#hello_3(3,17)

##########################
def hello_4(x):
    """For each number from 0 to x-1, print hello, and add 3 until it reached 15"""
    while x != 15:
        print('hello')
        x = x +3
    print('')

#hello_4(0)

#########################
def hello_5(x):
    """for each number from 0 to x-1, print 'hello' under conditions"""
    while x < 100:
        if x == 31:
            for k in range(7):
                print('hello')
        elif x == 18:
            print ('hello')
        x = x +1
    print('')

#hello_5(12)

###########################
# WHILE loop with BREAK
def hello_6(x,y):
    """for each number form x to y, print 'hello + str(y), and add 1 into y until y=6"""
    while x: # while x is True
        print("hello!" + str(y))
        y += 1 # increment y by 1
        if y == 6:
            break
    print('')

#hello_6 (True, 0)

##################################
def main(argv):
    """Main entry point of the program"""
    hello_1(12)
    hello_2(12)
    hello_3(3, 17)
    hello_4(0)
    hello_5(12)
    hello_6(True, 0)
    return 0

if __name__ == "__main__":
    status = main(sys.argv) 
    sys.exit(status) 
**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
hello
hello
hello
hello
 
hello
hello
hello
hello
 
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
 
hello
hello
hello
hello
hello

hello
hello
hello
hello
hello
hello
hello
hello

hello!0
hello!1
hello!2
hello!3
hello!4
hello!5


**********************************************************************

Code ran without errors

Time consumed = 0.03828s

======================================================================
Inspecting script file basic_io1.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""File input and improved using 'with' statement, 
print the lines of input lines and clear the blank lines."""

__appname__ = 'basic_io1'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

#############################
# FILE INPUT
#############################

## Simple sample ##
# Open a file for reading

#f = open('../sandbox/test.txt', 'r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
#for line in f:
#    print(line)

# close the file
#f.close()

#Same example, skip blank lines
#f = open('../sandbox/test.txt', 'r')
#for line in f:
#    if len(line.strip()) > 0:
#        print(line)

#f.close()
########################################################

# Rewritten using 'with' statement
with open('../sandbox/test.txt', 'r') as f:
    # use "implicit" for loop:
    # if the object is a file, python will cycle over lines 
    for line in f:
        print(line)

# Once you drop out of the with, the file is automatically closed

# Same example, skip blank lines
with open('../sandbox/test.txt', 'r') as f:
    for line in f:
        if len(line.strip()) > 0:
            print(line)

**********************************************************************

Testing basic_io1.py...

basic_io1.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2022-23/Coursework/StudentRepos/AnqiWang_/week2/code/basic_io1.py", line 37, in <module>
    with open('../sandbox/test.txt', 'r') as f:
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/test.txt'

======================================================================
Inspecting script file basic_io2.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""File output, create a .txt file cotaining numbers from 0 to 99"""
__appname__ = 'basic_io2'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

####################################
# FILE OUTPUT
#############################
# Save the elements of a list to a file
list_to_save = range(100)

f = open('../sandbox/testout.txt','w')
for i in list_to_save:
    f.write(str(i) + '\n') ## Add a new line at the end

f.close()
**********************************************************************

Testing basic_io2.py...

basic_io2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2022-23/Coursework/StudentRepos/AnqiWang_/week2/code/basic_io2.py", line 15, in <module>
    f = open('../sandbox/testout.txt','w')
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/testout.txt'

======================================================================
Inspecting script file boilerplate.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Docstring describes operation of the script, serves as documentation for the code"""
# use to access docstrings at run time
__appname__ = 'boilerplate'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

import sys

def main(argv):
    """ Main entry point of the programm"""
    print('This is a boilerplate')
    return 0

if __name__ == "__main__":
    """ Make sure the "main" function is called from command line """
    status = main(sys.argv)
    sys.exit(status)
  # sys.exit("EXITING . . .")  

#if (__name__ == "__main__"):
#    def main(argv):
#    print('This is a boilerplate') # NOTE: indented using two tabs or four spaces
#    sys.exit(status)
        
**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.02520s

======================================================================
Inspecting script file MyExampleScript.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Example Script to practice running scripts on"""
__appname__ = 'MyExampleScript'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

# Function
def foo(x):
    """print the square of the input"""
    x *= x
    print (x)

foo (2)
**********************************************************************

Testing MyExampleScript.py...

MyExampleScript.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
4

**********************************************************************

Code ran without errors

Time consumed = 0.02493s

======================================================================
Inspecting script file lc1.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Use list comprehensions and loops to make lists from bird data"""
__appname__ = 'lc1'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

from re import I

birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively. 

# Methods 1
birds_latin_names = [i[0] for i in birds]
birds_common_names = [i[1] for i in birds]
mean_body_masses = [i[2] for i in birds]

# Methods 2
BirdsLatinNames = [x for x, y, z in birds]
BirdsCommonNames = [y for x, y, z in birds]
MeanBodyMasses = [z for x, y, z in birds]

# (2) Now do the same using conventional loops (you can choose to do this 
# before 1 !). 
LatinNames = []
CommenNames = []
MeanBodyMasses_2 = []

for i in birds:
    LatinNames.append(i[0])
    CommenNames.append(i[1])
    MeanBodyMasses_2.append(i[2])

# A nice example out out is:
# Step #1:
# Latin names:
# ['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
# ... etc.
 
**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.02470s

======================================================================
Inspecting script file basic_csv.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Read data from testcsv.csv, 
print species information, 
and create a new .csv file cointaining species and bodymass"""

__appname__ = 'basic_csv'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

# import packages
import csv

# Read a file containing
# 'Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)'
with open ('../data/testcsv.csv','r') as f:

    csvread = csv.reader(f)
    temp = []
    for row in csvread:
        temp.append(tuple(row))
        print(row)
        print("The species is", row [0])


# Write a file containing only species name and Body mass
with open('../data/testcsv.csv', 'r') as f:
    with open('../data/bodymass.csv', 'w') as g:

        csvread = csv.reader(f)
        csvwrite = csv.writer(g)
        for row in csvread:
            print(row)
            csvwrite.writerow([row[0], row[4]])
            
**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']
The species is Species
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']
The species is Daubentonia_madagascariensis
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']
The species is Allocebus_trichotis
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']
The species is Avahi_laniger
['Avahi_occidentalis', 'Lemuriformes', 'Indridae', 'Madagasc
**********************************************************************

Code ran without errors

Time consumed = 0.02923s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Read the .csv file and determines whether the tree species are oaks or not"""

__appname__ = 'oaks_debugme'
__author__ = 'ANQI WANG (aw222@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "None"

import csv
import sys
import doctest

#Define function
def is_an_oak(name):
    """ Returns True if name is starts with 'quercus'
    >>> is_an_oak('Quercus robur')
    True
    >>> is_an_oak('Fraxinus excelsior')
    False
    >>> is_an_oak('Pinus sylvestris')
    False
    >>> is_an_oak('Quercus cerris')
    True
    >>> is_an_oak('Quercus petraea')
    True
    >>> is_an_oak('quercus petraea')
    True
    >>> is_an_oak('quercusss petraea')
    True
    >>> is_an_oak('QuercusPetraea')
    True
    """
    # use startswith() to catch bugs in spelling/spacing
    return name.lower().startswith('quercus')

def main(argv): 
    """Read the TestOaksData.csv as input data, and save the only oaks information as results into JustOaksData.csv"""
    #import ipdb; ipdb.set_trace()
    f = open('../data/TestOaksData.csv','r')
    g = open('../data/JustOaksData.csv','w')
    taxa = csv.reader(f)
    csvwrite = csv.writer(g)
    oaks = set()
    for row in taxa:
        print(row)
        print ("The genus is: ") 
        print(row[0] + '\n')
        if is_an_oak(row[0]):
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])    

    return 0
    
if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)

doctest.testmod()  # runs embedded doctests
**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
['Genus', ' species']
The genus is: 
Genus

['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!


**********************************************************************

Code ran without errors

Time consumed = 0.05047s

======================================================================
======================================================================
Finished running scripts

Ran into 4 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 100

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!